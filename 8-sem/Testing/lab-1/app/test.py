import pytest
import SegmentLine, SlopeInterceptLine, LineClassifier
from utils import InvalidLineException

###############################################################################
# Тести для допустимих класів ситуацій (коректні дані)
###############################################################################

@pytest.mark.parametrize("a1,b1,a2,b2,k3,b3", [
    # Test 1: Граничний випадок з великими від'ємними значеннями
    (-126, -126, -68, -68, -1, -124),

    # Test 2: Граничний випадок з великими позитивними значеннями
    (126, 126, 125, 125, -1, 124),

    # Test 3: Типовий випадок – перші дві прямі співпадають, і третя (кутове представлення) дає таке ж саме рівняння.
    (2, 3, 2, 3, 1, 5),

    # Test 4: Спеціальний випадок – перша пряма задається через більші значення, друга через менші, але обидві співпадають,
    # а кутове представлення (L3) перетворюється до того ж рівняння.
    (4, 6, 2, 3, -1.5, 6),

    # Test 5: Спеціальний випадок – друга і третя прямі співпадають за своїм рівнянням.
    (2, 7, 5, 5, -1, 5),

    # Test 6: Граничний випадок – перші дві прямі задані однаково (з від'ємними значеннями),
    # третя пряма отримує значення, що забезпечують співпадання.
    (-4, 6, -4, 6, 1, 1),
])
def test_coinciding(a1, b1, a2, b2, k3, b3):
    """
    Тести для класу 1: Прямі співпадають.

    У цих тестах усі три прямі повинні співпадати.
    Очікується, що результат містить ключову фразу "Прямі співпадають".
    """
    line1 = SegmentLine(a1, b1)
    line2 = SegmentLine(a2, b2)
    line3 = SlopeInterceptLine(k3, b3)
    classifier = LineClassifier(line1, line2, line3)
    result = classifier.classify()

    expected_str = "Прямі співпадають"
    assert expected_str in result, f"Результат '{result}' не містить '{expected_str}'"


# Клас 2: Прямі не перетинаються (усі три паралельні, але не співпадають (можуть співпасти тільки дві))
@pytest.mark.parametrize("a1,b1,a2,b2,k3,b3", [
    (-126, -126, -125, -125, -1, -125),
    (-120, -120, -118, -118, -1, -119),
    (10, -10, 20, -20, 1, 15),
    (126, 126, 125, 125, -1, 125),
    (120, 120, 118, 118, -1, 119),
    (120, -120, 18, -18, 1, 119)
])
def test_parallel(a1, b1, a2, b2, k3, b3):
    """
    Якщо всі три прямі паралельні (але не співпадають), має повернутися:
      "Прямі не перетинаються"
    """
    line1 = SegmentLine.SegmentLine(a1, b1)
    line2 = SegmentLine.SegmentLine(a2, b2)
    line3 = SlopeInterceptLine.SlopeInterceptLine(k3, b3)
    classifier = LineClassifier.LineClassifier(line1, line2, line3)
    result = classifier.classify()
    print(result)
    assert result == "Прямі не перетинаються"


# Клас 3: Прямі перетинаються в одній точці (конкурентні прямі)
@pytest.mark.parametrize("a1, b1, a2, b2, k3, b3, common_point", [
    # Test 1 (Граничний нижній): використання значень, близьких до -126
    (-126, 10, -125, 10, -126, 10, (0, 10)),
    # Test 2 (Граничний верхній): використання значень, близьких до 126
    (126, 10, 125, 10, 126, 10, (0, 10)),
    # Test 3 (Типові значення): середній діапазон
    (20, 10, 30, 10, 1, 10, (0, 10)),
    # Test 4 (Комбінація граничного і середнього): перша з граничних, друга з типових
    (-126, 10, 30, 10, 0, 10, (0, 10)),
])
def test_concurrent(a1, b1, a2, b2, k3, b3, common_point):
    """
    Тест для конкурентних прямих – всі три перетинаються в одній точці.
    Очікуване: рядок результату містить фразу "Прямі перетинаються в одній точці"
    і має містити координати спільної точки, наприклад, "(0.000000, 10.000000)".
    """
    line1 = SegmentLine.SegmentLine(a1, b1)
    line2 = SegmentLine.SegmentLine(a2, b2)
    line3 = SlopeInterceptLine.SlopeInterceptLine(k3, b3)
    classifier = LineClassifier.LineClassifier(line1, line2, line3)
    result = classifier.classify()

    print(result)

    # Очікуємо, що рядок містить ключову фразу для конкурентних прямих:
    expected_str = "Прямі перетинаються в одній точці"
    assert expected_str in result, f"Результат '{result}' не містить '{expected_str}'"

    # Перевіряємо, що спільна точка співпадає з очікуваною (за форматуванням до 6 знаків після коми)
    common_str = f"({common_point[0]:.6f}, {common_point[1]:.6f})"
    assert common_str in result, f"Спільна точка '{common_str}' не знайдена в результаті '{result}'"


# Клас 4: Прямі перетинаються в двох точках
@pytest.mark.parametrize("a1,b1,a2,b2,k3,b3,expected", [
    # Test 1: Граничний випадок з великими від'ємними значеннями
    (-126, -126, -125, -125, 0, 50, ((-176.000000, 50.000000), (-175.000000, 50.000000))),
    # Test 2: Типовий випадок з позитивними значеннями
    (100, 100, 90, 90, 1, 10, ((45.000000, 55.000000), (40.000000, 50.000000))),
    # Test 3: Типовий випадок з малими значеннями
    (3, 4, 6, 8, 2, 5, ((-0.300000, 4.400000), (0.900000, 6.800000))),
    # Test 4: Спеціальний випадок – комбінація негативних і позитивних параметрів
    (-50, 20, -40, 16, 0.5, -20, ((400.000000, 180.000000), (360.000000, 160.000000))),
    # Test 5: Граничний випадок із використанням максимальних значень
    (126, -126, 120, -120, 0, -10, ((116.000000, -10.000000), (110.000000, -10.000000))),
    # Test 6: Спеціальний випадок із змішанням малих від'ємних значень
    (-10, 50, -8, 40, 2, -20, ((-23.333333, -66.666667), (-20.000000, -60.000000))),
])
def test_two_intersections(a1, b1, a2, b2, k3, b3, expected):
    """
    Тести, де одна пара прямих паралельна, а третя їх перетинає.
    Результатом має бути повідомлення з двома різними точками перетину.
    """
    line1 = SegmentLine.SegmentLine(a1, b1)
    line2 = SegmentLine.SegmentLine(a2, b2)
    line3 = SlopeInterceptLine.SlopeInterceptLine(k3, b3)
    classifier = LineClassifier.LineClassifier(line1, line2, line3)
    result = classifier.classify()

    print(result)

    expected_str = "Прямі перетинаються в двох точках"
    assert expected_str in result, f"Результат '{result}' не містить '{expected_str}'"

    point1, point2 = expected
    common_str1 = f"({point1[0]:.6f}, {point1[1]:.6f})"
    assert common_str1 in result, f"Спільна точка '{common_str1}' не знайдена в результаті '{result}'"
    common_str2 = f"({point2[0]:.6f}, {point2[1]:.6f})"
    assert common_str2 in result, f"Спільна точка '{common_str2}' не знайдена в результаті '{result}'"


@pytest.mark.parametrize("a1,b1,a2,b2,k3,b3,expected", [
    # Test 1: Граничний випадок з великими від'ємними значеннями
    (-126, -126, -125, -124, 1, -50,
     ((-38.000000, -88.000000),
      (-37.148594, -87.148594),
      (-250.00000, 124.000000))),

    # Test 2: Типовий випадок з позитивними значеннями
    (100, 90, 80, 100, 1, 50,
     ((28.571429, 64.285714),
      (21.052632, 71.052632),
      (22.222222, 72.222222))),

    # Test 3: Типовий випадок з малими значеннями
    (3, 4, 4, 3, 2, 1,
     ((1.714286, 1.714286),
      (0.727273, 2.454545),
      (0.900000, 2.800000))),

    # Test 4: Спеціальний випадок – комбінація негативних і позитивних параметрів
    (-20, 50, 30, -60, 0.5, 10,
     ((-20.000000, 0.000000),
      (46.666667, 33.333333),
      (-220.000000, -500.000000))),

    # Test 5: Граничний випадок із використанням максимальних значень
    (126, 30, 125, 40, -1, 5,
     ((122.093023, 0.930233),
      (-32.812500, 37.812500),
      (-51.470588, 56.470588))),

    # Test 6: Спеціальний випадок із змішанням малих від'ємних значень та граничними
    (-126, 126, 50, -126, 0.75, -10,
     ((165.789474, 291.789474),
      (-544.000000, -418.000000),
      (65.536723, 39.152542))),
])
def test_three_intersections(a1, b1, a2, b2, k3, b3, expected):
    """
    Тести, де кожна пара прямих перетинається в унікальну точку (3 різні точки перетину).
    Результатом має бути повідомлення, яке містить фразу "Прямі перетинаються в трьох точках"
    та відформатований перелік трьох точок (точність 6 знаків після коми).
    """
    # Створюємо об’єкти прямої
    line1 = SegmentLine.SegmentLine(a1, b1)
    line2 = SegmentLine.SegmentLine(a2, b2)
    line3 = SlopeInterceptLine.SlopeInterceptLine(k3, b3)
    classifier = LineClassifier.LineClassifier(line1, line2, line3)
    result = classifier.classify()

    print(result)

    # Перевірка, що в результаті є фраза для трьох точок
    expected_phrase = "Прямі перетинаються в трьох точках"
    assert expected_phrase in result, f"Результат '{result}' не містить очікувану фразу '{expected_phrase}'"


    # Формуємо рядки для кожної очікуваної точки
    point1, point2, point3 = expected
    common_str1 = f"({point1[0]:.6f}, {point1[1]:.6f})"
    assert common_str1 in result, f"Спільна точка '{common_str1}' не знайдена в результаті '{result}'"
    common_str2 = f"({point2[0]:.6f}, {point2[1]:.6f})"
    assert common_str2 in result, f"Спільна точка '{common_str2}' не знайдена в результаті '{result}'"
    common_str3 = f"({point3[0]:.6f}, {point3[1]:.6f})"
    assert common_str3 in result, f"Спільна точка '{common_str3}' не знайдена в результаті '{result}'"

###############################################################################
# Тести для некоректного вводу (неприпустимі дані)
###############################################################################

def test_invalid_SegmentLine_a_zero():
    """
    Якщо a = 0 для представлення прямої виду x/a + y/b = 1, має бути викликаний виняток.
    """
    with pytest.raises(InvalidLineException):
        SegmentLine.SegmentLine(0, 1)

def test_invalid_SegmentLine_b_zero():
    """
    Якщо b = 0 для представлення прямої виду x/a + y/b = 1, має бути викликаний виняток.
    """
    with pytest.raises(InvalidLineException):
        SegmentLine.SegmentLine(4, 0)

def test_invalid_SlopeInterceptLine_b_zero():
    """
    Для прямої виду y = kx + b параметр b не може бути нульовим.
    """
    with pytest.raises(InvalidLineException):
        SlopeInterceptLine.SlopeInterceptLine(1, 0)

###############################################################################
# Тести для чисел, що виходять за межі проміжку [-126;126]
###############################################################################
# Припустимо, що в конструкторах класів додано перевірку на допустимість (abs(x) > 126)
def test_out_of_bound_a():
    with pytest.raises(ValueError):
        # Наприклад, якщо значення a більше 126, то має бути ValueError
        SegmentLine.SegmentLine(130, 10)

def test_out_of_bound_b():
    with pytest.raises(ValueError):
        SegmentLine.SegmentLine(10, 130)

def test_out_of_bound_slopeintercept():
    with pytest.raises(ValueError):
        SlopeInterceptLine.SlopeInterceptLine(1, 130)
